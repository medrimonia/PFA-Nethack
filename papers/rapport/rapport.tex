\documentclass[a4paper,11pt]{article}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{graphicx}
\usepackage{geometry}

\geometry{margin=2cm}

\begin{document}
\begin{center}
\begin{tabular*}{\textwidth}{l @{\extracolsep{\fill}} r}

  \includegraphics [width=40mm]{./images/ENSEIRB-MATMECA.ps} &
  \raisebox{0.75\height}
           {\includegraphics [width=40mm]{./images/logo-LaBRI-couleur.ps}}

\end{tabular*}

\vspace{\stretch{1}}

\textsc{\Huge Des bots pour NetHack}\\[0.5cm]
\rule{0.4\textwidth}{1pt}

\vspace{\stretch{1}}

\begin{center}
  
  \begin{flushleft}
    \large
    \emph{Auteurs :}\\
    \begin{itemize}
    \item Benoît Ruelle
    \item David Bitonneau
    \item Ludovic Hofer
    \end{itemize}
  \end{flushleft}
  
  
  \begin{flushright}
    \large
    \emph{Responsables :}\\
    Pédagogique - M.~Renault\\
    Client - M.~Le Borgne\\
  \end{flushright}
\end{center}

\vspace{\stretch{1}}
                  
{\large Deuxième année, filière informatique}

~

{\large 16 octobre 2012 - 29 mars 2013}\\
                  
\end{center}
\thispagestyle{empty}
\pagebreak

\tableofcontents
\pagebreak

\section{Introduction}

NetHack est un rogue-like (jeu inspiré du jeu vidéo \emph{Rogue} - 1980)
sorti en 1987. Le joueur incarne un aventurier chargé de récupérer une
amulette dans un donjon peuplé de monstres.


\section{Environnement de création de bots}

\subsection{Prototypage}

NetHack propose, dès sa première version, une interface ASCII qui représente un donjon sous la forme suivante:

\begin{verbatim}
                                           Weapons
                                           a - a blessed +1 mace (weapon in hand)
                                           Armor
   -------        ------------             b - a +0 robe (being worn)
   .......         ........>.|             c - a +0 small shield (being worn)
   |.....|        |..........|             Comestibles
   |......#       |@.........|             e - a clove of garlic
   |<....|#       |..........+             f - a sprig of wolfsbane
   |.....|#       -.---- -----             Spellbooks
   -------############                     g - a spellbook of create monster
         #############                     h - a spellbook of detect food
         # #        ##                     Potions
                                           d - 4 potions of holy water
                      .                    Tools
                      ..                   i - an oil lamp
                       ..                  (end) 
                       ...
                       ...
                       ----

JohnDoe the Aspirant          St:11 Dx:14 Co:13 In:11 Wi:15 Ch:11  Chaotic
Dlvl:1  $:0  HP:14(14) Pw:8(8) AC:7  Exp:1
\end{verbatim}

Le \verb!@! désigne le joueur, les caractères \verb!|! et \verb!-! sont des murs, les \verb!#! des couloirs, un \verb!+! symbolyse une porte, etc.


\subsubsection*{Séquences d'échapement ANSI}

Cette interface fonctionne à l'aide de caractères d'échapement normalisés \footnote{http://www.inwap.com/pdp10/ansicode.txt} permettant de contrôler la position du curseur dans un terminal et d'afficher des caractères à l'endroit souhaité. Par exemple, une séquence '\verb![46;50H|...+#!' affichera la chaîne de caractères '\verb!|...+#!' en commançant à la ligne 46, colone 50. Il est alors facile de reconstituer une carte envoyée par le jeu: le '\verb!|!' est aux coordonnées (46, 50), le '\verb!+!' est situé à (46, 54), etc.
	
	Le projet TAEB (Tactical Amulet Extraction Bot) \footnote{https://github.com/sartak/TAEB} utilise ce principe pour reconstituer la carte à l'aide d'un module sachant interpréter ces séquences de caractères \footnote{https://metacpan.org/module/Term::VT102}. Une première approche fut donc de copier ce procédé.


\subsubsection*{Pseudo-terminal}

Pour empêcher certaines formes de tricheries, NetHack procède à quelques vérifications pour s'assurer qu'il est bien lancé depuis un terminal, ce qui empêche les redirections de son entrée/sortie. Les quelques lignes de code responsables peuvent être désactivées sans conséquence notable sur le reste du jeu mais cela nécessite de modifier le code original. Pour rediriger à la fois l'entrée et la sortie du jeu sans modifier le jeu, il est nécessaire de 'tromper' NetHack à l'aide d'un pseudo terminal.

Un pseudo terminal (pty) est une paire de pseudo périphériques dont l'un est appelé 'maître' et l'autre 'esclave'. Le maître est utilisé comme un terminal standard sur lequel on peut écrire ou lire du texte. L'esclave communique avec l'application et sert simplement de rapporteur entre la partie 'maître' et NetHack. Ainsi, le jeu est satisfait puisqu'il est lancé depuis un terminal et il peut maintenant être contrôlé depuis la partie 'master' du pty sur laquelle on souhaite brancher un bot \footnote{Plus de détails avec la page de manuel pty(7) ou sur http://rachid.koucha.free.fr/tech\_corner/pty\_pdip.html}.


\subsubsection*{Décomposition de l'affichage}

Lorsqu'il est lancé depuis un terminal, l'interface ASCII détecte le nombre de lignes et de colonnes disponibles afin de faire des défilements ou des superpositions de menus lorsque nécessaire \footnote{voir termcap}. Cela pose problème avec la méthode consistant à interpréter les séquences d'échappement car il faut être capable détecter lorsque deux éléments se chevauchent.

\begin{figure}[H]
	\caption{Exemple d'un menu recouvrant une partie de la carte}
	\begin{verbatim}
                                     Weapons
                                     a - a blessed +1 mace (weapon in hand)
             ------                  i - a crude bow
             |...[|                  Armor
 -------     |..<..###############`  b - a +0 robe (being worn)
 |......-    .....|       ---------- c - a +0 small shield (being worn)
 |           -.----      #.........| Comestibles
              ##       ###|........| e - a clove of garlic
               #       #  |........| f - a sprig of wolfsbane
               ###   ###  |........| Spellbooks
                 #   #    |........| g - a spellbook of detect food
                 ### #    |........| h - a spellbook of clairvoyance
                ?  # #    --.------- Potions
               ----.-#      ###@#### d - 4 potions of holy water
               |....|#               j - a blessed black potion
               |....|#               (end) 
               +.....#                         |..... ..$|
               |....|                          |.........|
               ------                          |.........|
                                               -----------

JohnDoe the Aspirant          St:10 Dx:14 Co:13 In:9 Wi:18 Ch:11  Chaotic
Dlvl:1  $:0  HP:14(14) Pw:7(7) AC:7  Exp:1
	\end{verbatim}
\end{figure}

Une façon de supprimer cette difficulté est de tromper une nouvelle fois NetHack en manipulant la taille effective du pseudo terminal qui n'est en rien liée à sa taille réelle à l'écran. Avec une taille assez grande, il n'y a jamais de chevauchement.

Nous pouvons ainsi séparer l'écran comme suit en forçant une taille de 24 lignes par 160 colonnes :

\begin{verbatim}
               Messages line ................ --more--
               ----------------------------------------
               |                  |                   |
               |                  |                   |
               |    MAP 21x80     |     MENU 21x80    |
               |                  |                   |
               |                  |                   |
               ----------------------------------------
               Status line 1 .........................
               Status line 2 .........................
\end{verbatim}

\subsubsection*{Branchement d'un bot}

Cette interface permettait à un bot de communiquer avec NetHack depuis une machine distante (UDP ou TCP interchangeables) sans aucune modification du jeu original. Dans la version présentée dans le premier livrable, l'intégralité de la carte était retransmise au bot et les échanges avec le jeu souffraient de l'overhead des packets TCP ou UDP lorsque le bot et NetHack tournaient sur la même machine. Des améliorations alors envisagées étaient d'établir un protocole de communication plus complexe pour n'envoyer que les éléments ayant changé et de recourir aux sockets Unix pour des communications locales.

Les communications entre l'interface et un bot utilisaient le protocole suivant.

\paragraph{interface vers bot:} À chaque tour, l'information envoyée par l'interface commence par \verb!START! et se termine par \verb!END!. Pour toutes les différentes transmissions, il existe deux possibilités différentes :
\begin{itemize}
	\item Mono-ligne \verb!<NOM_VARIABLE> <VARIABLE_1> <VARIABLE_2> ...!
	\item Multi-ligne
		\begin{verbatim}
		START <NOM_VARIABLE>
		...
		...
		END <NOM_VARIABLE>
		\end{verbatim}
\end{itemize}
Les caractères représentant la carte sont transmis sans transformation. Exemple:
\begin{verbatim}
START
DUNGEON_LEVEL 1
MAP_HEIGHT 6
MAP_WIDTH 10
START MAP
          
   ----   
  |...@+  
  |....|  
   ----   
          
END MAP
END
\end{verbatim}

\paragraph{bot vers interface:} À chaque tour le bot peut accomplir une et une seule action. Une action est définie par son type et ses paramètres (ex : l'action d'attaquer est définie par son type 'attaque' et la direction de l'attaque). Les actions possibles étaient définies par un langage faisant abstraction des commandes au clavier de NetHack :
\begin{itemize}
	\item Déplacement : \verb!MOVE <direction>!
	\item Ouvrir porte : \verb!OPEN <direction>!
	\item Lancer une recherche : \verb!SEARCH!
	\item Forcer une porte : \verb!FORCE <direction>! (permet d'ouvrir les portes verrouillées)
\end{itemize}
\noindent La direction étant un élément parmi \verb!NORTH!, \verb!SOUTH!, \verb!WEST!, \verb!EAST!, \verb!NORTH_WEST!, \verb!NORTH_EAST!, \verb!SOUTH_WEST!, \verb!SOUTH_EAST!, \verb!UP!, \verb!DOWN!.


\subsection{Interface finale}

À la demande du client et du responsable pédagogique, l'utilisation d'une interface intégrée directement dans le jeu fut implémentée. Elle permet d'économiser une étape d'entrée/sortie lors de la communication avec un bot mais a le désaventage de rendre impossible l'utilisation du projet sur une version originale du jeu.

Pour cela, nous avons utilisé une structure fournie par le NetHack regroupant des pointeurs de fonction à appeler lors d'un évènement à communiquer au joueur. C'est sur ce mécanisme que repose la plupart des interfaces graphiques existantes pour le jeu.

Décomposition, archi, env variables, hooks, choix sur les glyphes (ambiguitées), systèmes de
patchs (simplicité, intégration).

\begin{itemize}
\item Choix pour l'interface (sockets, etc).
\item Protocole.
\end{itemize}

\subsection{Développement de bots.}

BDD, généricité (protocole, socket, différents langages).
Algos de bots.

\subsection{Outils d'analyse et de deboguage}

Plusieurs outils ont été mis à disposition pour faciliter le développement des bots et l'analyse de leurs performances.

\subsubsection*{Rejouer une partie}

Parler de l'extraction de la graine.

\subsubsection*{Revoir d'une partie}

	Si la sauvegarde du replay a été activée lors du lancement du jeu (à l'aide de la variable d'environnement \verb!NH_MM_REPLAY!), un fichier nethackdir/replay est créé. Il contient tous les échanges de l'interface vers le bot, selon le même protocole, pour être capable de reconstituer le déroulement d'une partie.

Le programme viewer.pl permet d'interpréter ce fichier en décomposant son contenu par tour de jeu. Ses fonctionnalitées sont :
\begin{itemize}
	\item reconstitution tour par tour
	\item revenir en arrière tour par tour
	\item saut direct à un numéro de tour donné
	\item 'diaporama' par incrémentation ou décrémentation d'un nombre de tours par seconde donné
\end{itemize}

Un échange entre l'interface et le bot au tour $N$ ne permet pas de reconstituer l'état de la partie au tour $N$ car seules les mises à jour sont transmises. Il est donc nécessaire de traîter tous les échanges depuis le début de la partie pour connaître l'état du jeu à un tour donné. La reconstitution de longues parties peut alors devenir lente pour des opérations simples. Par exemple, passer du tour 2000 au tour 1999 nécessiterais de rejouer 1999 tours pour faire un simple saut en arrière.

Une meilleure exploitation des informations contenues dans le fichier de replay est de calculer l'inverse des mises à jour qu'il contient et/ou de stocker des états paliers du jeu (tous les 100 tours par exemple). Dans \verb!viewer.pl! seule la méthode des mises à jour inverses est implémentée. Elles permettent de revenir en arrière rapidement et un passage d'un tour $N$ à un tour $M$ se fait simplement en traitant tous les tours de $N$ à $M$ si $|N-M| < M$ ou de $0$ à $M$ sinon. Certains paliers sont tout de même utilisés lors du changement de niveaux pour ne pas avoir à retracer les sales des niveaux inférieurs qui seront de toute manière effacées lors d'un retour en arrière.

\subsubsection*{Scripts de génération de graphes}

Expliquer les scripts


\section{Analyses}

graphes, sous-section pour chaque "mode". Reprendre étude pièce rectangulaire.


\section{Travail en équipe, organisation}

Utilisation de git.
Comparer avec le travail en plus grande équipe.

\end{document}
