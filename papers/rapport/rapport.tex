\documentclass[a4paper,11pt]{article}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{geometry}

\geometry{margin=2cm}

\begin{document}
\begin{center}
\begin{tabular*}{\textwidth}{l @{\extracolsep{\fill}} r}

  \includegraphics [width=40mm]{./images/ENSEIRB-MATMECA.ps} &
  \raisebox{0.75\height}
           {\includegraphics [width=40mm]{./images/logo-LaBRI-couleur.ps}}

\end{tabular*}

\vspace{\stretch{1}}

\textsc{\Huge Des bots pour NetHack}\\[0.5cm]
\rule{0.4\textwidth}{1pt}

\vspace{\stretch{1}}

\begin{center}
  
  \begin{flushleft}
    \large
    \emph{Auteurs :}\\
    \begin{itemize}
    \item Benoît Ruelle
    \item David Bitonneau
    \item Ludovic Hofer
    \end{itemize}
  \end{flushleft}
  
  
  \begin{flushright}
    \large
    \emph{Responsables :}\\
    Pédagogique - M.~Renault\\
    Client - M.~Le Borgne\\
  \end{flushright}
\end{center}

\vspace{\stretch{1}}
                  
{\large Deuxième année, filière informatique}

~

{\large 16 octobre 2012 - 29 mars 2013}\\
                  
\end{center}
\thispagestyle{empty}
\pagebreak

\tableofcontents
\pagebreak

\section{Introduction}

NetHack est un rogue-like (jeu inspiré du jeu vidéo \emph{Rogue} - 1980)
sorti en 1987. Le joueur incarne un aventurier chargé de récupérer une
amulette dans un donjon peuplé de monstres.


\section{Environnement de création de bots}

\subsection{Prototypage}

NetHack propose, dès sa première version, une interface ASCII qui représente un donjon sous la forme suivante:

\begin{verbatim}
                                           Weapons
                                           a - a blessed +1 mace (weapon in hand)
                                           Armor
   -------        ------------             b - a +0 robe (being worn)
   .......         ........>.|             c - a +0 small shield (being worn)
   |.....|        |..........|             Comestibles
   |......#       |@.........|             e - a clove of garlic
   |<....|#       |..........+             f - a sprig of wolfsbane
   |.....|#       -.---- -----             Spellbooks
   -------############                     g - a spellbook of create monster
         #############                     h - a spellbook of detect food
         # #        ##                     Potions
                                           d - 4 potions of holy water
                      .                    Tools
                      ..                   i - an oil lamp
                       ..                  (end) 
                       ...
                       ...
                       ----

JohnDoe the Aspirant          St:11 Dx:14 Co:13 In:11 Wi:15 Ch:11  Chaotic
Dlvl:1  $:0  HP:14(14) Pw:8(8) AC:7  Exp:1
\end{verbatim}

Le \verb!@! désigne le joueur, les caractères \verb!|! et \verb!-! sont des murs, les \verb!#! des couloirs, un \verb!+! symbolyse une porte, etc.


\subsubsection*{Séquences d'échapement ANSI}

Cette interface fonctionne à l'aide de caractères d'échapement normalisés \footnote{http://www.inwap.com/pdp10/ansicode.txt} permettant de contrôler la position du curseur dans un terminal et d'afficher des caractères à l'endroit souhaité. Par exemple, une séquence '\verb![46;50H|...+#!' affichera la chaîne de caractères '\verb!|...+#!' en commançant à la ligne 46, colone 50. Il est alors facile de reconstituer une carte envoyée par le jeu: le '\verb!|!' est aux coordonnées (46, 50), le '\verb!+!' est situé à (46, 54), etc.
	
	Le projet TAEB (Tactical Amulet Extraction Bot) \footnote{https://github.com/sartak/TAEB} utilise ce principe pour reconstituer la carte à l'aide d'un module sachant interpréter ces séquences de caractères \footnote{https://metacpan.org/module/Term::VT102}. Une première approche fut donc de copier ce procédé.


\subsubsection*{Pseudo-terminal}

Pour empêcher certaines formes de tricheries, NetHack procède à quelques vérifications pour s'assurer qu'il est bien lancé depuis un terminal, ce qui empêche les redirections de son entrée/sortie. Les quelques lignes de code responsables peuvent être désactivées sans conséquence notable sur le reste du jeu mais cela nécessite de modifier le code original. Pour rediriger à la fois l'entrée et la sortie du jeu sans modifier le jeu, il est nécessaire de 'tromper' NetHack à l'aide d'un pseudo terminal.

Un pseudo terminal (pty) est une paire de pseudo périphériques dont l'un est appelé 'maître' et l'autre 'esclave'. Le maître est utilisé comme un terminal standard sur lequel on peut écrire ou lire du texte. L'esclave communique avec l'application et sert simplement de rapporteur entre la partie 'maître' et NetHack. Ainsi, le jeu est satisfait puisqu'il est lancé depuis un terminal et il peut maintenant être contrôlé depuis la partie 'master' du pty sur laquelle on souhaite brancher un bot \footnote{Plus de détails avec la page de manuel pty(7) ou sur http://rachid.koucha.free.fr/tech\_corner/pty\_pdip.html}.


\subsubsection*{Branchement d'un bot}

Cette interface permettait à un bot de communiquer avec NetHack depuis une machine distante (UDP ou TCP interchangeables) sans aucune modification du jeu original. Dans la version présentée dans le premier livrable, l'intégralité de la carte était retransmise au bot et les échanges avec le jeu souffraient de l'overhead des packets TCP ou UDP lorsque le bot et NetHack tournaient sur la même machine. Des améliorations alors envisagées étaient d'établir un protocole de communication plus complexe pour n'envoyer que les éléments ayant changé et de recourir aux sockets Unix pour des communications locales.

Les communications entre l'interface et un bot utilisaient le protocole suivant.

\paragraph{interface vers bot:} À chaque tour, l'information envoyée par l'interface commence par \verb!START! et se termine par \verb!END!. Pour toutes les différentes transmissions, il existe deux possibilités différentes :
\begin{itemize}
	\item Mono-ligne \verb!<NOM_VARIABLE> <VARIABLE_1> <VARIABLE_2> ...!
	\item Multi-ligne
		\begin{verbatim}
		START <NOM_VARIABLE>
		...
		...
		END <NOM_VARIABLE>
		\end{verbatim}
\end{itemize}
Les caractères représentant la carte sont transmis sans transformation. Exemple:
\begin{verbatim}
START
DUNGEON_LEVEL 1
MAP_HEIGHT 6
MAP_WIDTH 10
START MAP
          
   ----   
  |...@+  
  |....|  
   ----   
          
END MAP
END
\end{verbatim}

\paragraph{bot vers interface:} À chaque tour le bot peut accomplir une et une seule action. Une action est définie par son type et ses paramètres (ex : l'action d'attaquer est définie par son type 'attaque' et la direction de l'attaque). Les actions possibles étaient définies par un langage faisant abstraction des commandes au clavier de NetHack :
\begin{itemize}
	\item Déplacement : \verb!MOVE <direction>!
	\item Ouvrir porte : \verb!OPEN <direction>!
	\item Lancer une recherche : \verb!SEARCH!
	\item Forcer une porte : \verb!FORCE <direction>! (permet d'ouvrir les portes verrouillées)
\end{itemize}
\noindent La direction étant un élément parmi \verb!NORTH!, \verb!SOUTH!, \verb!WEST!, \verb!EAST!, \verb!NORTH_WEST!, \verb!NORTH_EAST!, \verb!SOUTH_WEST!, \verb!SOUTH_EAST!, \verb!UP!, \verb!DOWN!.


\subsection{Interface finale}

Décomposition, archi, env variables, hooks, choix sur les glyphes (ambiguitées), systèmes de
patchs (simplicité, intégration).

\begin{itemize}
\item Choix pour l'interface (sockets, etc).
\item Protocole.
\end{itemize}

\subsection{Développement de bots.}

BDD, généricité (protocole, socket, différents langages).
Algos de bots.

\subsection{Outils d'analyse et de deboguage}

Plusieurs outils ont été mis à disposition pour faciliter le développement des bots et l'analyse de leurs performances.

\subsubsection*{Rejouer une partie}

Parler de l'extraction de la graine.

\subsubsection*{Replay d'une partie}

Parler de viewer.pl, toTikZ.pl

\subsubsection*{Scripts de génération de graphes}

Expliquer les scripts


\section{Analyses}

graphes, sous-section pour chaque "mode". Reprendre étude pièce rectangulaire.


\section{Travail en équipe, organisation}

Utilisation de git.
Comparer avec le travail en plus grande équipe.

\end{document}
