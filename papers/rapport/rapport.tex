\documentclass[a4paper,12pt]{article}
\usepackage[frenchb]{babel}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc} 
%Pour avoir un rendu plus beau
\usepackage{lmodern}
\usepackage{float}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{amsmath}
\usepackage{tikz}
\usepackage{pdfpages}
\usepackage{bigfoot}
\usetikzlibrary{trees}

\graphicspath{{graphics}{../images/}}

\geometry{margin=2cm}

\begin{document}
\begin{center}
\begin{tabular*}{\textwidth}{l @{\extracolsep{\fill}} r}

  \includegraphics [width=40mm]{ENSEIRB-MATMECA.jpg} &
  \raisebox{0.75\height}
           {\includegraphics [width=40mm]{logo-LaBRI-couleur.jpg}}

\end{tabular*}

\vspace{\stretch{1}}

\textsc{\Huge Des bots pour NetHack}\\[0.5cm]
\rule{0.4\textwidth}{1pt}

\vspace{\stretch{1}}

\begin{center}
  
  \begin{flushleft}
    \large
    \emph{Auteurs :}\\
    \begin{itemize}
    \item Benoît Ruelle
    \item David Bitonneau
    \item Ludovic Hofer
    \end{itemize}
  \end{flushleft}
  
  
  \begin{flushright}
    \large
    \emph{Responsables :}\\
    Pédagogique - M.~Renault\\
    Client - M.~Le Borgne\\
  \end{flushright}
\end{center}

\vspace{\stretch{1}}
                  
{\large Deuxième année, filière informatique}

~

{\large 16 octobre 2012 - 29 mars 2013}\\
                  
\end{center}
\thispagestyle{empty}
\pagebreak

\tableofcontents
\pagebreak

\section{Introduction}

NetHack est un rogue-like (jeu inspiré du jeu vidéo \emph{Rogue} - 1980)
sorti en 1987. Le joueur incarne un aventurier chargé de récupérer une
amulette dans un donjon peuplé de monstres.
Les enjeux du projet sont multiples : il s'agit tout d'abord de proposer une
base au développement de bots pour NetHack puis, dans un second temps, de
fournir des méthodes d'évaluation de ces bots. Pour cela la modification du code
de NetHack est nécessaire afin d'établir un moyen de communication entre le
noyau du jeu et les bots ; NetHack étant un jeu écrit en C et sous licence
libre, son code source est disponibles et modifiable. Afin d'évaluer les bots
différents outils de benchmarking ont été mis en place ; ces outils reposent
sur la récupération de données et le stockage de celles-ci afin d'effectuer
des statistiques et produire des graphiques de comparaison.
Par ailleurs, un certain nombre de simplifications du jeu original ont été
opérées dans le but de faciliter le développement des bots et permettre
l'étude de problèmes plus spécifiques.  

Le projet consiste donc en un ensemble de modifications du code du jeu
original, d'ajout d'outils, de fonctionnalités et d'études théorique.

\subsection*{Description du jeu}
TODO
-> Ensembles de donjons, de niveau, de cases, etc.
-> monstres, pièges, faims, quêtes, objets, personnages, etc.

\subsubsection*{Commandes principales}

Les commandes les plus utilisées pour l'exploration d'un niveau sont les suivantes :

\begin{itemize}
	\item \verb!j! (direction) vers le bas
	\item \verb!k! (direction) vers le haut
	\item \verb!h! (direction) vers la gauche
	\item \verb!l! (direction) vers la droite
	\item \verb!y! (direction) diagonale vers le haut à gauche
	\item \verb!u! (direction) diagonale vers le haut à droite
	\item \verb!b! (direction) diagonale vers le bas à gauche
	\item \verb!n! (direction) diagonale vers le bas à droite
	\item \verb!o<direction>! ouvrir la porte se trouvant dans la direction donnée
	\item \verb!^D<direction>! enfoncer la porte se trouvant dans la direction donnée
	\item \verb!<! emprunter l'escalier menant au niveau supérieur
	\item \verb!>! emprunter l'escalier menant au niveau inférieur
\end{itemize}

Bien d'autres commandes sont disponibles, se référer à la documentation du
jeu pour une liste complète.

\subsection*{Définitions}

%Les modes de jeu

\paragraph{}
\emph{Noyau (de NetHack)} : désigne de manière générale le code original de
NetHack et de façon plus précise tout ce qui concerne la logique du jeu en
faisant abstraction des diverses interfaces graphiques et portions dépendantes
de l'architecture.

\paragraph{}
\emph{Hook} : terme désignant ici un point d'entrée dans du code. Ce terme est
employé pour évoquer les appels de fonction rajoutée dans le cœur du code
de NetHack afin de pouvoir effectuer des traitements personnalisés. Les
'hooks' permettent par exemple de récupérer des statistiques issues du
déroulement d'une partie, directement depuis le noyau de NetHack.

\paragraph{}
\emph{Starter package} : ici au sujet des bots, désigne un bot volontairement
simpliste servant d'exemple à la création d'autres bot dans le même langage.
La gestion de la communication avec le jeu étant déjà implémentée dans le
"starter package", il suffit de reprendre le code afin de n'avoir à gérer que
la stratégie.

\section{Architecture finale}

Bien que le développement du projet ait majoritairement suivi le schéma
défini dans le document de spécification, certaines détails ont légèrement
changé. Par exemple, un effort a été fait pour réduire autant que possible
le nombre de références à des fichiers externes dans les patchs sur le noyau
de Nethack. Pour arriver à ce résultat, nous nous sommes servis du header
{\em pfa\_main.h} comme point d'entrée.
\footnote{Il est facile de vérifier les dépendances ajoutées à l'aide de
  l'instruction suivante :\\
{\verb*|grep "+#include \".*\"" install/*.patch|}}
\\
Nous avons développé la majeure partie du code en {\em C}, mais certaines
parties du code se sont tout de même révélées beaucoup plus simples à
écrire en {\em bash}\footnote{Les scripts de générations de graphiques ou de
  lancement d'un grand nombre de parties} ou en {\em perl}
\footnote{Le viewer et l'outil toTikZ}, à cause de leur nature très variable
et de la nature des tâches effectuées. Cependant, après avoir acquis plus
d'expérience sur l'utilisation de gnuplot en {\em C}, il semble que transposer
les codes de génération des graphiques en {\em C} pourrait assurer une
meilleure maintenabilité\footnote{Nous n'avons pas fourni cet effort car en
discutant avec le client, nous avons compris qu'il préférait obtenir plus de
graphiques fournissant des informations que d'avoir une génération de graphe
en {\em C} mais moins complète}.

\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{architecture-finale.png}}
	\caption{\label{fig:architecture} Diagramme de l'architecture finale.}
\end{figure}

\paragraph{Communication avec les bots :}
Les échanges entre les bots et le middle-man sont effectués à l'aide d'une
socket unix, le protocole utilisé entre eux est détaillé dans ce rapport et doit
pouvoir permettre des créer des bots dans d'autres langages.


\paragraph{Patches :}
L'utilisation des patches permet de visualiser facilement quels sont les
modifications apportées à nethack. Pour une plus grande facilité de
développement, mais aussi pour plus de clarté, nous avons utilisé autant que
possibles des 'hooks', ceux-ci passant tous par pfamain afin de réduire au
maximum le nombre d'include ajoutés dans les patches.

\paragraph{Obtention de données par game statistics :}
Afin d'obtenir les données internes au jeu, game statistics doit nécessairement
se servir d'une part du code existant de nethack, afin de connaître le nombre de
cases explorables par exemple.

\paragraph{Gestion de la base de données :}
Les modules {\em game\_result} et {\em database\_manager} sont étroitement
liés, car tous deux se basent sur la description des différentes tables pour
générer leur code.

\paragraph{Fichier de replay :}
Afin de pouvoir revoir une partie qui s'est jouée, le middle-man fournit une
option permettant de sauvegarder les données envoyées au bot. Celles-ci peuvent
aussi être lues pour créer une visualisation de l'exploration à l'aide du script
perl {\em toTikz.pl}.%TODO ok Benoît?

\paragraph{Scripts :}
Même s'ils ne sont pas présentés sur ce schéma car ils ne font pas partie
intégrante du logiciel, des scripts bash permettent de créer des graphiques à
partir de base de données qui ont été alimentées par cette version de nethack.


\section{Environnement de création de bots}

\subsection{Prototypage}

NetHack propose, dès sa première version, une interface ASCII qui représente
un donjon sous la forme suivante:

\begin{figure}[H]
\begin{verbatim}
                                           Weapons
                                           a - a blessed +1 mace (weapon in hand)
                                           Armor
   -------        ------------             b - a +0 robe (being worn)
   .......         ........>.|             c - a +0 small shield (being worn)
   |.....|        |..........|             Comestibles
   |......#       |@.........|             e - a clove of garlic
   |<....|#       |..........+             f - a sprig of wolfsbane
   |.....|#       -.---- -----             Spellbooks
   -------############                     g - a spellbook of create monster
         #############                     h - a spellbook of detect food
         # #        ##                     Potions
                                           d - 4 potions of holy water
                      .                    Tools
                      ..                   i - an oil lamp
                       ..                  (end) 
                       ...
                       ...
                       ----

JohnDoe the Aspirant          St:11 Dx:14 Co:13 In:11 Wi:15 Ch:11  Chaotic
Dlvl:1  $:0  HP:14(14) Pw:8(8) AC:7  Exp:1
\end{verbatim}
\end{figure}

Le \verb!@! désigne le joueur, les caractères \verb!|! et \verb!-! sont des
murs, les \verb!#! des couloirs, un \verb!+! symbolise une porte, etc.


\subsubsection*{Séquences d'échappement ANSI}

Cette interface fonctionne à l'aide de caractères d'échappement normalisés
\footnote{http://www.inwap.com/pdp10/ansicode.txt} permettant de contrôler la
position du curseur dans un terminal et d'afficher des caractères à l'endroit
souhaité. Par exemple, une séquence '\verb![46;50H|...+#!' affichera la chaîne
de caractères '\verb!|...+#!' en commençant à la ligne 46, colonne 50. Il est
alors facile de reconstituer une carte envoyée par le jeu: le '\verb!|!' est
aux coordonnées (46, 50), le '\verb!+!' est situé à (46, 54), etc.
	
Le projet TAEB (Tactical Amulet Extraction Bot)
\footnote{https://github.com/sartak/TAEB} utilise ce principe pour
reconstituer la carte à l'aide d'un module sachant interpréter ces séquences
de caractères \footnote{https://metacpan.org/module/Term::VT102}. Une première
approche fut donc de copier ce procédé.


\subsubsection*{Pseudo-terminal}

Pour s'assurer de la disponibilité de certaines fonctionnalités lorsqu'il est
utilisé avec son interface ASCII, NetHack procède à quelques vérifications
pour s'assurer qu'il est bien lancé depuis un terminal. Cela empêche les
redirections de son entrée/sortie car il refuse alors de s'exécuter. Les
quelques lignes de code responsables peuvent être désactivées sans conséquence
notable sur le reste du jeu mais cela nécessite de modifier le code original.
Pour rediriger à la fois l'entrée et la sortie du jeu sans modifier le jeu, il
est nécessaire de 'tromper' NetHack à l'aide d'un pseudo terminal.

Un pseudo terminal (pty) est une paire de pseudo périphériques dont l'un est
appelé 'maître' et l'autre 'esclave'. Le maître est utilisé comme un terminal
standard sur lequel on peut écrire ou lire du texte. L'esclave communique avec
l'application et sert simplement de rapporteur entre la partie 'maître' et
NetHack. Ainsi, le jeu est satisfait puisqu'il est lancé depuis un terminal et
il peut maintenant être contrôlé depuis la partie 'master' du pty sur laquelle
on souhaite brancher un bot \footnote{Plus de détails avec la page de manuel
pty(7)}.


\subsubsection*{Décomposition de l'affichage}

Lorsqu'il est lancé depuis un terminal, l'interface ASCII détecte le nombre de
lignes et de colonnes disponibles afin de faire des défilements ou des
superpositions de menus lorsque nécessaire \footnote{voir libtermcap}. Cela
pose problème avec la méthode consistant à interpréter les séquences
d'échappement car il faut être capable détecter lorsque deux éléments se
chevauchent.

\begin{figure}[h]
	\caption{Exemple d'un menu recouvrant une partie de la carte}
	\begin{verbatim}
                                     Weapons
                                     a - a blessed +1 mace (weapon in hand)
             ------                  i - a crude bow
             |...[|                  Armor
 -------     |..<..###############`  b - a +0 robe (being worn)
 |......-    .....|       ---------- c - a +0 small shield (being worn)
 |           -.----      #.........| Comestibles
              ##       ###|........| e - a clove of garlic
               #       #  |........| f - a sprig of wolfsbane
               ###   ###  |........| Spellbooks
                 #   #    |........| g - a spellbook of detect food
                 ### #    |........| h - a spellbook of clairvoyance
                ?  # #    --.------- Potions
               ----.-#      ###@#### d - 4 potions of holy water
               |....|#               j - a blessed black potion
               |....|#               (end) 
               +.....#                         |..... ..$|
               |....|                          |.........|
               ------                          |.........|
                                               -----------

JohnDoe the Aspirant          St:10 Dx:14 Co:13 In:9 Wi:18 Ch:11  Chaotic
Dlvl:1  $:0  HP:14(14) Pw:7(7) AC:7  Exp:1
	\end{verbatim}
\end{figure}

Une façon de supprimer cette difficulté est de tromper une nouvelle fois
NetHack en manipulant la taille effective du pseudo terminal qui n'est en rien
liée à sa taille réelle à l'écran. Avec une taille assez grande, il n'y a
jamais de chevauchement.

Nous pouvons ainsi séparer l'écran comme suit en forçant une taille de 24
lignes par 160 colonnes :

\begin{figure}[H]
\begin{verbatim}
               Messages line ................ --more--
               ----------------------------------------
               |                  |                   |
               |                  |                   |
               |    MAP 21x80     |     MENU 21x80    |
               |                  |                   |
               |                  |                   |
               ----------------------------------------
               Status line 1 .........................
               Status line 2 .........................
\end{verbatim}
\end{figure}

\subsubsection*{Branchement d'un bot}

Cette interface permettait à un bot de communiquer avec NetHack depuis une
machine distante (UDP ou TCP interchangeables) sans aucune modification du jeu
original. Dans la version présentée dans le premier livrable, l'intégralité de
la carte était retransmise au bot et les échanges avec le jeu souffraient de
l'overhead des packets TCP ou UDP lorsque le bot et NetHack tournaient sur la
même machine. Des améliorations alors envisagées étaient d'établir un
protocole de communication plus complexe pour n'envoyer que les éléments ayant
changé et de recourir aux sockets Unix pour des communications locales.

Les communications entre l'interface et un bot utilisaient le protocole
suivant.

\paragraph{interface vers bot:} À chaque tour, l'information envoyée par
l'interface commence par \verb!START! et se termine par \verb!END!. Pour
toutes les différentes transmissions, il existe deux possibilités différentes
:
\begin{itemize}
	\item Mono-ligne \verb!<NOM_VARIABLE> <VARIABLE_1> <VARIABLE_2> ...!
	\item Multi-ligne
		\begin{verbatim}
		START <NOM_VARIABLE>
		...
		...
		END <NOM_VARIABLE>
		\end{verbatim}
\end{itemize}
Les caractères représentant la carte sont transmis sans transformation. Exemple:
\begin{figure}[H]
\begin{verbatim}
START
DUNGEON_LEVEL 1
MAP_HEIGHT 6
MAP_WIDTH 10
START MAP
          
   ----   
  |...@+  
  |....|  
   ----   
          
END MAP
END
\end{verbatim}
\end{figure}

\paragraph{bot vers interface:} À chaque tour le bot peut accomplir une et une
seule action. Une action est définie par son type et ses paramètres (ex :
l'action d'attaquer est définie par son type 'attaque' et la direction de
l'attaque). Les actions possibles étaient définies par un langage faisant
abstraction des commandes au clavier de NetHack :
\begin{itemize}
	\item Déplacement : \verb!MOVE <direction>!
	\item Ouvrir porte : \verb!OPEN <direction>!
	\item Lancer une recherche : \verb!SEARCH!
	\item Forcer une porte : \verb!FORCE <direction>! (permet d'ouvrir les portes verrouillées)
\end{itemize}
\noindent La direction étant un élément parmi \verb!NORTH!, \verb!SOUTH!,
\verb!WEST!, \verb!EAST!, \verb!NORTH_WEST!, \verb!NORTH_EAST!,
\verb!SOUTH_WEST!, \verb!SOUTH_EAST!, \verb!UP!, \verb!DOWN!.


\subsection{Modifications de NetHack}

\subsubsection{Interface finale}

\paragraph{}À la demande du client et du responsable pédagogique,
l'utilisation d'une interface intégrée directement dans le jeu fut
implémentée. Elle permet d'économiser une étape d'entrée/sortie lors de la
communication avec un bot mais a le désavantage de rendre impossible
l'utilisation du projet sur une version originale du jeu.


Pour cela, nous avons utilisé une structure fournie par le NetHack regroupant
des pointeurs de fonction à appeler lors d'un évènement à communiquer au
joueur. C'est sur ce mécanisme que repose la plupart des interfaces graphiques
existantes pour le jeu. Les principales fonctions appelées sont les suivantes
:
\begin{itemize}
	\item \verb!int *_create_nhwindows(type)! : cette fonction est appelée
		lors de la création d'une fenêtre (afficher un menu par exemple). Le
		type donné en paramètre donne la nature de la fenêtre et sa valeur
		peut être \verb!NHW_MAP!, \verb!NHW_SATUS!, \verb!NHW_MESSAGE!,
		\verb!NHW_MENU!, \verb!NHW_TEXT!. En comparaison avec le découpage de
		l'écran de l'interface précédente, cette façon de distinguer les
		différentes fenêtres est beaucoup moins sujette à erreur et ne devrait
		pas souffrir d'un changement d'organisation des fenêtres si un jour
		NetHack devait évoluer.
	\item \verb!void *_clear_nhwindow(id)! : cette fonction ne fait qu'effacer
		le contenu d'une fenêtre mais elle est intéressante dans le cas où
		\verb!id! est l'identifiant de la fenêtre associée à la carte. En
		effet, c'est un moyen simple, bien que peu sûr, de détecter un
		changement d'étage au niveau de l'interface. La détection certaine
		d'un changement d'étage peut néanmoins se faire au niveau du client
		(le bot) qui comprendra qu'un effacement de la carte juste après une
		montée ou une descente d'une échelle correspond effectivement à un
		changement d'étage.
	\item \verb!void *_print_glyph(id, x, y, glyph)! : cette fonction sert à
		communiquer au joueur qu'un glyph dans la fenêtre d'identifiant
		\verb!id! se situe aux coordonnées \verb!(x, y)!. \verb!glyph! est un
		entier unique à chaque élément du jeu. NetHack fourni une fonction
		\verb!map_glyph! qui le transforme en un caractère qui peut être
		directement affiché à l'écran (\verb!@! pour un joueur, \verb!+! pour
		une porte, etc.). Cette dernière fonction peut retourner des
		caractères identiques pour des glyphs différents et cela est à prendre
		en compte lors de l'élaboration du protocole pour éviter des
		confusions au niveau du bot.
	\item \verb!char *_yn_function(query,resp, def)! : cette fonction est
		appelée dès lors que NetHack pose une question au client. Le nom est
		trompeur car elle ne sert pas seulement aux questions dont la réponse
		est 'yes' ou 'no'. Elle est utilisée par exemple pour savoir dans
		quelle direction frapper si le client donne l'ordre de combattre.
	\item \verb!int *_nh_poskey(x, y, mod)! : cette fonction attend une
		commande de l'utilisateur. Les paramètres ne nous concernent pas car
		ils sont utilisés dans le cas où l'interface supporte la souris.
\end{itemize}

\paragraph{}Le paramétrage se fait avec des variables d'environnement :
\begin{itemize}
\item \verb!NH_MM_SOCKPATH! : spécifier un chemin pour la socket unix
	(permettant la communication entre NetHack et les bots) à créer. Par
	défaut, le middleman créé \emph{/tmp/mmsock}.
\item \verb!NH_MM_REPLAY! : si mise à une valeur différente de 0, cette
	variable active l'enregistrement de la partie dans le fichier
	\emph{nethackdir/replay}. Désactivée par défaut.
\item \verb!NH_MM_LOGGING! : si mise à une valeur différente de 0, cette
	variable active l'enregistrement de logs du middleman dans le fichier
	\emph{nethackdir/mm.log}. Désactivée par défaut.
\item \verb!NH_MM_TIMEOUT! : spécifie le timeout en secondes pour les
	communications avec le bot. Si le bot met un temps en secondes supérieur à
	cette valeur, le middleman quitte la partie. Par défaut, cette variables
	est mise à 2 secondes.
\item \verb!NH_MAX_MOVES! :
  Ce paramètre spécifie le nombre de mouvement maximal autorisé au bot, sachant
  que le bot n'est pas sensé mourir, c'est la définition de ce paramètre qui
  spécifiera la durée de la partie. Par défaut, cette variable vaut 20000.
\item \verb!NH_DATABASE_PATH! :
  Spécifie le chemin d'accès pour la base de données à laquelle les résultats
  seront ajoutés. Par défaut, ce chemin vaut \emph{/tmp/test.db}.
\item \verb!NH_BOT_NAME! :
  Permet d'indiquer le nom du bot afin d'ajouter une entrée complète à la base
  de données. Par défaut : la valeur est \emph{unknown}.
\item \verb!NH_MODE_NAME! :
  Permet d'indiquer le nom du mode utilisé afin de l'ajouter correctement à la
  base de données. Par défaut : la valeur est \emph{seek\_secret}.
\item \verb!NH_SEED! :
  Permet de donner la valeur de la graine à utiliser pour l'initialisation du
  générateur de nombres aléatoires de NetHack. Par défaut, si cette
  valeur n'est pas spécifiée, la graine utilisée est une combinaison du nombre
  de secondes et de millisecondes écoulées depuis l'epoch \footnote{$1^{er}$
  janvier 1970 à 0 heure (UTC)}.

\end{itemize}

\paragraph{} Cette nouvelle interface ne permet plus d'observer, depuis
NetHack, le comportement du bot. Le jeu propose diverses interfaces
graphiques, une solution aurait donc très bien pu être de rediriger les appels
aux fonctions de l'interface que nous avons développée vers celles d'une
interface existante. Cependant, cela pose un problème non négligeable : les
différentes interfaces graphiques s'autorisent des fonctions bloquantes
(fenêtre de dialogue propres à chacune d'elles par exemple). A moins de
supprimer ou d'adapter les fonctions gênantes, il n'est pas envisageable
d'utiliser cette solution avec un bot.

Une autre solution aurait été de permettre un affichage simple dans le
terminal. Cela n'a pas été retenu car cela aurait consisté à faire des
traitements supplémentaires pour reconstituer la carte et cela reviendrait à
dupliquer le travail que le bot doit déjà faire de lui même.

\paragraph{} Le protocole de communication entre un bot et le jeu a été
modifié depuis le prototype. L'interface retransmet à l'identique au noyau de
NetHack les commandes transmises par le bot. C'est à dire que le client doit
utiliser les commandes originales du jeu et que le langage faisant abstraction
de celles-ci a été abandonné. Exception est faite des commandes commençant par
'\verb!#!' qui ne sont pas supportées. Ceci est dû au code original de NetHack
qui cherche à réaliser des traitements particuliers pour ce type de commande
(auto complétion, etc.) que nous n'avons pas jugé utile d'implémenter.

Un bot peut envoyer plusieurs commandes à la fois ce qui peut se montrer utile
pour diminuer le nombre d'échanges avec le jeu et ou d'appels systèmes pour un
gain de performances. Les commandes à envoyer en une seule fois est toutefois
limitée à 64 octets. Par exemple, envoyer les commandes '\verb!jjkl!' aura le
même effet que d'envoyer chacune des lettres séparément et fera bouger le
joueur deux fois vers le bas, une fois vers le haut et une fois vers la
droite. Il est donc recommandé au développeur d'un bot de prendre en charge
des patterns : '\verb!oj!' pour ouvrir une porte au sud, etc.

Quant au protocole concernant les échanges depuis l'interface vers le bot,
nous avons établi les règles suivantes :
\begin{itemize}
	\item \verb!S! marque le début d'une transmission
	\item \verb!E! marque la fin d'une transmission et indique que l'interface
		attend une commande du client.
	\item \verb!g<x><y><glyph><code>! indique qu'un élément du jeu représenté
		par le caractère \verb!glyph! et ayant pour code identificateur
		\verb!code! \footnote{Voir annexe pour les différents codes
		importants} se trouve aux coordonnées \verb!(x, y)!.
	\item \verb!C! indique que la carte doit être effacée. Un bot peut
		interpréter cette information comme étant un changement d'étage réussi
		s'il venait d'envoyer une commande descente ou montée d'escalier.
\end{itemize}


\subsubsection*{Développement par les patchs}

\paragraph{} L'un de nos objectifs était d'adapter NetHack en ayant la plus
petite empreinte possible sur le code existant. C'est dans ce but que nous
avons opté pour l'installation de 'hooks' dans le code source faisant appels à
nos fonctions définies dans leur propre emplacement, dans un répertoire
séparé. Ces points d'entrés sont placés à des endroits stratégiques :
\begin{itemize}
	\item Le premier est installé dans la fonction \verb!moveloop()! de
		\verb!allmain.c! du jeu qui est exécutée par toutes les architectures
		supportées. Elle fait alors appel à \verb!pfa_init()! du fichier
		\verb!pfamain.c! et se situe juste avant la boucle principale.
		\verb!pfa_init()! regroupe toutes les procédures d'initialisation
		nécessaires au modules que nous avons développés.
	\item Le second se trouve au début la boucle principale de
		\verb!moveloop()! pour nous permettre d'effectuer des traitements à
		chaque tour de jeu. Il fait appel à \verb!pfa_newloop()!.
	\item Le dernier est placé dans la fonction \verb!terminate(status)! du
		fichier \verb!end.c! appelée lorsque NetHack quitte afin de nous
		donner l'occasion de terminer proprement (libération de la mémoire,
		fermeture des fichiers, etc.). Il fait appel à \verb!pfa_end()!.
\end{itemize}

\paragraph{} Nous souhaitions également pouvoir livrer nos modifications
indépendamment du jeu lui même. Nous avons donc utilisé un système de patchs
installant les points d'entrée aux endroits voulus. Ce même procédé est
utilisé pour les modifications correspondant aux 'modes' (suppression des
monstres, suppression des objets, etc.). Le processus d'installation a été
automatisé pour qu'à partir d'une archive originale de NetHack le code source
soit patché pour prendre en compte nos ajouts et modifications.

\textbf{TODO David: configuration des patchs à appliquer pour chaque mode et
	expliquer ce que ces patchs font + donner un exemple de patch avec détail
	des lignes changées et l'effet sur le jeu.}


\subsection{Développement de bots.}

\subsubsection{'Bot' contrôlé à la main}

L'interface développée ne permet plus de jouer au jeu à la main et donc de
tester nous même les modifications apportées au jeu. Nous avons donc développé
un client adapté au protocole mis en place. Il s'agit du programme
\verb!dummy-client.pl!. Il accepte les mêmes commandes que le jeu original et
nous a permis, entre autre, de tester l'effet des patchs sur une partie.


\subsubsection{Le starter package java}
Afin de pouvoir rapidement commencer à coder des bots, un \emph{starter package}
en java est fourni, les fonctionnalités fournies sont principalement la lecture
de la carte et la vérification de la validité des mouvements.
\\
Ce bot se contente de lister les actions possibles et d'en choisir une de façon
aléatoire, avec tout de même certaines actions prioritaires. Cette base permet
de pouvoir tester différentes stratégie sans avoir à implémenter à nouveau la
réception et l'envoi de message aux bots.

\subsubsection{Le bot diffusion}
Le principe de ce bot est d'établir des scores pour chaque cases et de diffuser
ensuite les valeurs à tous les voisins, ainsi la principale différence avec les
autres bots est que la complexité est bien plus élevée étant donnée que pour
choisir la prochaine action, il n'y a pas que le voisinage immédiat qui est
observé. Ce surcoût de temps permet en revanche d'avoir des meilleurs résultats
et la possibilité de modifier les scores facilement permet de changer les
objectifs en changeant uniquement des constantes.
\\
Une fois tous les scores calculés et la diffusion effectuée, l'action choisie
est celle ayant le score le plus élevé parmi celles qui sont autorisées. Ce bot
est donc totalement déterministe. Quelques attentions ont été portées à
l'optimisation afin de réduire légèrement le temps d'exécution, cependant, il
est certainement possible d'améliorer encore grandement les performances en
optimisant certaines parties du code.

\subsubsection{Le starter package python}

Ce bot propose un squelette pour l'interprétation des messages venant du jeu
et un algorithme simple pour l'exploration 'rapide' d'un niveau en maintenant
un compteur pour chaque case visitée. Le bot se déplace en priorité sur les
cases les moins visitées.

\subsubsection{Le bot spécialisé}

Ce bot, écrit en python, n'a pas vocation à être utilisé dans des conditions
"normales" de jeu. C'est un bot dédié à la résolution optimale d'un problème
particulier : trouver, en un nombre de tours minimal, la porte secrète cachée
de façon aléatoire dans une salle carrée de taille 10x10. Une étude théorique
de ce problème a été réalisée et ce bot a pour but de s'approcher de la
solution optimale. Ceci permet d'effectuer une comparaison avec les autres
bots qui sont plus "généralistes".

Afin d'utiliser ce bot dans les bonnes conditions, il est nécessaire d'avoir
compilé une version du jeu dans laquelle le patch
\emph{patches/create\_level.patch} a été appliqué. Ce patch modifie le donjon
de telle sorte que le premier niveau ne contienne qu'une seule salle de la
forme décrite précédemment\footnote{ce niveau ne contient pas d'escalier pour
descendre dans les niveaux suivants}.


\subsection{Outils d'analyse et de deboguage}

Plusieurs outils ont été mis à disposition pour faciliter le développement des
bots et l'analyse de leurs performances.

\subsubsection{Rejouer une partie}

\textbf{TODO: David} Parler de l'extraction de la graine.

\subsubsection{Revoir une partie}

Si la sauvegarde du replay a été activée lors du lancement du jeu (à l'aide de
la variable d'environnement \verb!NH_MM_REPLAY!), un fichier nethackdir/replay
est créé. Il contient tous les échanges de l'interface vers le bot, selon le
même protocole, pour être capable de reconstituer le déroulement d'une partie.

Le programme \verb!viewer.pl! permet d'interpréter ce fichier en décomposant
son contenu par tour de jeu. Ses fonctionnalités sont :
\begin{itemize}
	\item reconstitution tour par tour
	\item revenir en arrière tour par tour
	\item saut direct à un numéro de tour donné
	\item 'diaporama' par incrémentation ou décrémentation d'un nombre de
		tours par seconde donné
\end{itemize}

Un échange entre l'interface et le bot au tour $N$ ne permet pas de
reconstituer l'état de la partie au tour $N$ car seules les mises à jour sont
transmises. Il est donc nécessaire de traiter tous les échanges depuis le
début de la partie pour connaître l'état du jeu à un tour donné. La
reconstitution de longues parties peut alors devenir lente pour des opérations
simples. Par exemple, passer du tour 2000 au tour 1999 nécessiterait de
rejouer 1999 tours pour faire un simple saut en arrière.

Une meilleure exploitation des informations contenues dans le fichier de
replay est de calculer l'inverse des mises à jour qu'il contient et/ou de
stocker des états paliers du jeu (tous les 100 tours par exemple). Dans
\verb!viewer.pl! seule la méthode des mises à jour inverses est implémentée.
Elles permettent de revenir en arrière rapidement et un passage d'un tour $N$
à un tour $M$ se fait simplement en traitant tous les tours de $N$ à $M$ si
$|N-M| < M$ ou de $0$ à $M$ sinon. Certains paliers sont tout de même utilisés
lors du changement de niveaux pour ne pas avoir à retracer les salles des
niveaux inférieurs qui seront de toute manière effacées lors d'un retour en
arrière.

\subsubsection{Aperçu du nombre de visites sur chaque case}

Le fichier nethackdir/replay peut également être utilisé dans d'autres buts.
Par exemple, un simple programme comptant le nombre de visite sur chaque
coordonnée permet de produire les images suivantes à l'aide de TikZ :

\begin{figure}[H]
	\caption{Nombre de visites sur chaque case sur deux niveaux du starter
	package java. En blanc les cases non visitées, en jaune clair les cases
visitées peu de fois, en rouge les cases visitées un grand nombre de fois.}
	\resizebox{\columnwidth}{!}{\input{../common/javasp_tikz_exemple.tex}}
\end{figure}

En comparaison avec le bot diffusion, on distingue deux comportements bien
différents : l'exploration totalement aléatoire du starter package visite
toutes les cases ou presque en passant beaucoup de temps dans chaque salle,
tandis que le bot diffusion passe beaucoup de temps dans les couloirs et moins
dans les salles.

\begin{figure}[H]
	\caption{Nombre de visites sur chaque case sur deux niveaux du bot diffusion.}
	\resizebox{\columnwidth}{!}{\input{../common/diffusion_tikz_exemple.tex}}
\end{figure}


\subsubsection{Stockage des résultats}
Les résultats des parties sont stockés dans une base de données afin de ne pas
perdre trop d'informations et de pouvoir effectuer toute sorte d'analyses à
partir de ceux-ci. Nous avons cherché à conserver toutes les informations
présentant une certaine utilité à nos yeux plutôt que de ne conserver que celles
que nous utilisons directement. Ce choix nous permet d'avoir plus de liberté
lors du choix des analyses et de ne pas avoir à relancer d'autres parties en
nous apercevant qu'une autre donnée serait nécessaire pour pouvoir tirer
certaines conclusions\footnote{Par exemple, les premières analyses nous ont fait
  penser que certains bots descendaient au second niveau alors que les bots
  n'utilisaient pas l'ordre permettant de descendre. Il nous était impossible de
  vérifier cela sur les données obtenues, car le niveau atteint n'était pas
  stocké à ce moment là.}.
\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{schema.png}}
	\caption{\label{fig:schema} Schéma de la base de données utilisée.}
\end{figure}
Une vue
fournissant certains détails supplémentaires \footnote{Nombre de portes
secrètes, nombre de portes secrètes trouvées, nombre de couloirs secrets et
nombre de couloirs secrets trouvés.} est aussi disponible afin de faciliter
l'utilisation de la base de données.
\\
Nous avons choisi d'utiliser une base de données {\em sqlite3}, celle-ci étant
assez simple à interfacer avec du {\em c}, mais aussi à interroger directement
par ligne de commande. Le grand avantage pour notre situation est aussi que les
bases de données {\em sqlite3} se présentent sous la forme d'un unique fichier,
celui-ci n'étant pas trop volumineux, il était parfaitement concevable de nous
échanger les bases de données de manière simple.
%TODO Parler des .def etc?


\subsubsection{Scripts de génération de graphiques}

Afin de visualiser les performances des différents bots, de pouvoir les comparer
facilement et de pouvoir vérifier statistiquement des propriétés de nethack,
nous avons mis en place des scripts permettant de générer de façon automatique
différents graphiques à partir d'une base de données. Ces graphiques se séparent
en trois catégories principales :
\begin{itemize}
\item Les graphiques permettant de mieux évaluer la répartition des performances
  des bots. Ceux-ci permettant entre autre de détecter que le bot ne fonctionne
  pas comme souhaité.
\item Les graphiques permettant de comparer les bots entre eux. Ceux-ci
  représentent la performance des bots sur un critère particulier en fonction du
  nombre maximal de mouvements autorisés. Ils permettent de départager les
  différentes stratégies par rapport à des objectifs.
\item Les graphiques analysant des données qui ne sont pas spécifiques au bot
  afin de permettre de vérifier certaines propriétés ou d'observer la
  distribution de certains événements aléatoires propres à nethack.
\end{itemize}
Tous les graphiques sont générés à l'aide de {\em gnuplot}, le type de sortie
peut facilement être modifié et permet ainsi de convenir à ce qui est attendu

\paragraph{Graphiques analysant un bot}

\subparagraph{Exemple}
Nous avons écrit un script permettant de générer un grand nombre de graphiques
indiquant la répartition des performances du bot. Celui-ci génère un graphique
par triplet
$\{\text{Bot},\text{Nb mouvements autorisés},\text{Caractéristique} \}$, il
faut par conséquent faire attention car suivant la base de données utilisée,
le temps de génération peut être conséquent. Voici un exemple d'un des graphes
produits par ce script.

\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{m_10000_nb_squares_explored.png}}
	\caption{\label{fig:impulse_graph} Un exemple de graphique montrant la
    répartition des performances}
\end{figure}

\subparagraph{Observation de caractéristiques du jeu}
Il est important de noter que ce script ne génère pas des graphes de répartition
que pour les performances du bot, il génère un graph similaire pour le résultat
maximal de chaque caractéristique, ce qui permet aussi d'observer la répartition
de celle-ci pour nethack. Nous avons ainsi constaté que la plupart des
caractéristiques \footnote{Nombre de portes secrètes présentes sur un niveau,
nombre de couloirs secrets présents sur un niveau et nombre de cases
explorables} que nous avons observées suivaient une distribution ayant en tout
cas l'apparence d'une gaussienne.
\\
Suivant les objectifs du bot, on peut donc imaginer qu'un bot se serve des
résultats obtenus afin de déterminer s'il est probable qu'il existe une autre
salle cachée où s'il a déjà tout visité. Cet aspect sera approfondi dans la
section {\em Analyses}.

\subparagraph{Observation de caractéristiques du bot}
Si l'exemple donné ci-dessus présente le nombre de cases explorées par le bot
comme suivant une gaussienne, certains aspects de répartition peuvent donner
plus d'informations, comme c'est le cas sur ce graphique.

\begin{figure}[H]
  \center{\includegraphics[width=0.5\textwidth]{nb_squares_explored.png}}
  \caption{\label{fig:nb_squares_explored} Un exemple de graphique montrant un
  dysfonctionnement du bot.}
\end{figure}

Le fait que la répartition des résultats ne suit pas une gaussienne n'est pas
forcément flagrant, en revanche, on distingue un nombre non négligeable de
parties ayant un nombre de cases explorées inférieur à 50, ce qui est très
faible en comparaison de la moyenne. En observant plus en détail une des
parties ayant obtenu un tel résultat, nous nous sommes rendus compte que le
problème venait du fait que les portes ne s'ouvraient plus, ce qui était dû à
une légère erreur lors d'une modification du noyau. Ces graphiques peuvent
donc aussi servir à détecter des dysfonctionnements lors de modifications du
noyau.

\paragraph{Graphiques comparant des bots}
Afin de comparer les performances des bots dans différents domaines, nous
avons écrit un script générant des graphiques permettant de visualiser
facilement les différences de résultats entre les différents bots. Celui-ci
génère un graphe par caractéristique observée, permettant ainsi de réduire le
nombre de manipulations à effectuer.

\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{graph_percent_scorrs_found.png}}
  \caption{\label{fig:move_graph} Un exemple de graphique comparant des bots}
\end{figure}

Il est possible de donner des noms différents au même bot au fur et à mesure
qu'il évolue, en ajoutant des données à la même base, ainsi il est possible de
mesurer l'amélioration des performances. Ce raisonnement s'applique aussi à
des modifications de paramètres sur le bot diffusion par exemple, ce qui
pourrait permettre par exemple de faire de l'apprentissage sur les différents
paramètres afin de trouver les valeurs idéales. Le problème du bot diffusion
étant que lancer de nombreuses parties demande un temps d'exécution important.

\paragraph{Graphiques analysant la distribution des portes et couloirs secrets}
Afin d'observer des informations sur la distribution des portes et couloirs
secrets, nous avons créé des scripts permettant de visualiser le nombre de
portes secrètes ou de couloir secrets pour chaque emplacement. La possibilité de
visualiser l'information en deux ou en trois dimensions est fournie. En deux
dimensions, deux graphiques sont disponibles, l'un représentant le nombre
d'éléments trouvés en fonction de la ligne, l'autre en fonction de la colonne.
Seul le graphique en trois dimensions permet de visualiser les deux
simultanément. S'appuyant sur {\em gnuplot}, les scripts générant les graphiques
en trois dimensions proposent un mode interactif permettant de changer l'angle
de vue.

\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{3d_exemple.png}}
  \caption{\label{fig:move_graph} Aperçu de la visualisation du nombre de
    couloirs secrets en fonction de la position.}
\end{figure}

L'utilité exacte de ce type de graphiques sera approfondie dans la partie
{\em Analyses}.


\section{Analyses}

Le code fourni nous a permis non seulement de comparer l'efficacité des bots
existants dans différents modes de jeu, mais aussi d'analyser certains aspects
de nethack. Pour tous ces tests, nous n'avons finalement utilisé qu'un seul
ensemble de patchs, celui associé à l'exploration. Les modifications de
l'expérience de jeu par rapport à la version originale de nethack sont les
suivantes :

\begin{itemize}
\item Désactivation de la faim.
\item Désactivation de tous les monstres.
\item Désactivation des objets normaux et spéciaux.
\item Désactivation des pièges\footnote{Si le nombre de piège a été grandement
  réduit, il reste malgré tout des portes piégées qui tuent ou assomment parfois
  le personnage lorsque l'on descend dans les niveaux}
\item Disparition des portes lorsqu'elles sont ouvertes ou défoncées
  \footnote{Ce patch s'est révélé pratique afin de simplifier la distinction
    entre les murs et les portes ouvertes, en effet, cela permet de ne pas
    inclure les portes ouvertes dans le protocole.}.
\end{itemize}

\subsection{Recherche d'éléments secrets}
Le but de ce mode est de retrouver toutes les portes secrètes et les couloirs
secrets présents dans le niveau initial. Une des contraintes est donc de ne pas
descendre d'étage. Les descentes accidentelles semblent effectivement avoir été
évitées étant donné que sur plus de 18'000 parties jouées dans ce mode par trois
bots différents, aucune n'a un niveau maximal atteint supérieur à 1.
\\
Nous avons aussi observé le pourcentage de cases visitées, même si ce n'était
pas un but directement affiché, après plusieurs expériences, celle-ci semble
naturellement suivre la même tendance que les deux autres.
\\
Afin de présenter des données à jour, nous avons lancé dans la dernière semaine
plus de 18'000 parties dont les résultats ont servis à générer les graphiques
qui seront présentés par la suite. Pour chacun de ceux-ci, tous les points
représentent la moyenne des résultats sur au moins 1000 parties. Cet ordre de
grandeur nous permet de réduire fortement le risque que les données présentées
soient biaisées par un mauvais échantillons.
\\
Sur tous les graphiques de comparaisons, {\em java-sp} sert de référence, ce bot
étant totalement aléatoire, il donne un exemple des résultats obtenus par un bot
ne présentant aucune intelligence mais qui ne risque pas de tomber dans des
boucles infinies.

\subsubsection{Pourcentage de portes secrètes trouvées}

\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{graph_percent_sdoors_found.png}}
  \caption{\label{fig:sdoors_found} Pourcentage de portes secrètes trouvées en
    fonction du nombre de mouvements autorisé}
\end{figure}

Les deux bots {\em évolués} ont des performances nettement meilleures que le bot
aléatoire, ce qui est assez rassurant sur leur fiabilité. Cette différence
montre aussi que même si le bot aléatoire augmente son pourcentage de détection
lorsque le nombre maximal de mouvements augmente, il nécessitera un nombre de
mouvement bien plus conséquent pour découvrir la moitié des portes secrètes.
\\
Bien que le bot {\em diffusion} trouve les portes plus rapidement que
{\em python-sp}, cette différence ne vaut pas nécessairement le surcoût engendré
par la différence de complexité asymptotique. Les données présentées ici
permettent néanmoins de pouvoir orienter son choix en connaissance de cause.

\subsubsection{Pourcentage de couloirs secrets trouvée}

\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{graph_percent_scorrs_found.png}}
  \caption{\label{fig:scorrs_found} Pourcentage de couloirs secrets trouvés en
    fonction du nombre de mouvements autorisé}
\end{figure}

La tendance générale ressemble beaucoup à celle obtenue pour les portes
secrètes, cependant en s'attardant un peu plus sur le graphique, on s'aperçoit
que la différence entre les bots est plus importante. Ceci peut être expliqué
par le fait que le bot {\em diffusion} accorde une priorité plus grande aux
couloirs aboutissant à des cul-de-sac et que le bot {\em python-sp} une fois
bloqué aura tendance à faire de nombreuses recherches, %TODO verify by Benoit
en revanche, le bot aléatoire aura tendance à faire très peu de recherche dans
ces emplacements là\footnote{Cette différence est illustrée dans la partie
{\em Aperçu du nombre de visites sur chaque case}.}.
\\
On peut constater qu'effectivement le bot aléatoire découvre moins de 30\% des
couloirs secrets avec 10'000 mouvements alors qu'il découvrait plus de 50\% des
portes secrètes avec cette même limite.

\subsubsection{Pourcentage de cases explorées}

\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{graph_percent_explored.png}}
  \caption{\label{fig:squares_explored} Pourcentage de cases explorées en
    fonction du nombre de mouvements autorisé}
\end{figure}

La différence entre le bot aléatoire et les autres est aussi grande que pour les
deux catégories précédentes, cependant on peut observer que lorsque le nombre de
mouvements autorisé est faible, le bot {\em python-sp} explore plus de cases que
le bot {\em diffusion}. Cette différence s'explique assez facilement grâce aux
différences de stratégie. Le bot {\em diffusion} n'a pas tendance à explorer
toutes les cases à portée étant donné qu'elles ne sont pas toutes susceptibles
d'être à proximité d'un couloir secret ou d'une porte secrète \footnote{À
  nouveau, observer la visualisation de l'exploration du niveau permet de s'en
  rendre compte rapidement}. Cette tendance s'inverse à un moment donné,
sûrement lorsque le bot {\em python-sp} est bloqué car il doit découvrir une
porte secrète ou un couloir secret pour progresser tandis que le bot diffusion a
découvert toutes les salles. Si l'on souhaite améliorer les performances du bot
{\em diffusion} pour cette caractéristique, il suffit à priori de changer le
score attribué à la découverte d'une nouvelle case\footnote{Celui-ci étant
négligeable dans la version utilisée pour les parties concernées par ce
graphique}.

\subsection{Descente dans les niveaux}

TODO Données manquantes.

\subsection{Évaluation des bots}
Pour un temps de calcul du même ordre que le bot aléatoire, le bot
{\em python-sp} offre une qualité d'exploration incomparablement supérieure.
Cependant, il n'est pas fait pour être adapté à des changements d'objectifs
rapidement contrairement au bot {\em diffusion} qui obtient des scores
d'exploration élevés tout en permettant de changer les buts très facilement. Ces
avantages ont en revanche un coût en complexité très élevé \footnote{ Il devrait
néanmoins être possible d'améliorer grandement le temps d'exécution de ce bot
avec des solutions algorithmiques plus poussées.}.

\subsection{Éléments indépendants des bots}
Certaines de nos analyses ne concernaient pas des bots, mais le jeu lui-même. En
effet, bien que le jeu se base sur un générateur aléatoire, cela ne signifie pas
que toutes les positions ont la même probabilité de contenir une porte par
exemple. Pour répondre à ce type de question, le bot utilisé importe peu, il
n'est même pas nécessaire d'utiliser un bot à priori, il suffit de générer la
carte.
\\
Les éléments que nous avons choisis d'observer sont la probabilité qu'une case
contienne une porte secrète ou un couloir secret en fonction de leurs positions.

\paragraph{Événements dépendants}
Avant de présenter certains résultats que nous avons obtenus, il est important
de préciser quelques points théoriques. Pour ce faire, nous allons utiliser les
notations suivantes :
\begin{itemize}
\item $C_{l,c}$ :
  représente le contenu de la case à ligne $l$ et à la colonne $c$.
\item $A_{l,c}$ :
  représente {\em l'apparence}\footnote{L'apparence signifie ce que perçoit le
    joueur, il peut par exemple percevoir un mur à une position alors que le
    contenu est une porte secrète.} de la case à ligne $l$ et à la colonne $c$.
\item $M$ :
  représente le type {\em mur}.
\item $PS$ :
  représente le type {\em porte secrète}.
\item $CS$ :
  représente le type {\em couloir secret}.
\end{itemize}

Les données qui sont acquises vont donner une estimation pour tout couple
$\{l,c\}$ de $P(C_{l,c} = PS)$ et de $P(C_{l,c} = CS)$. Cependant, ces estimations
ne fournissent pas un résultat directement utilisable pour les bots, car la
probabilité que le contenu soit d'un type donné dépend du type apparent.
\footnote{$P(C_{l,c} = CS | A_{l,c} = M) \neq P(C_{l,c} = CS)$ de manière flagrante
  car si l'apparence est un mur, le contenu ne peut pas être un couloir secret}
\\
Cette dépendance des variables implique que les valeurs qui nous intéressent
réellement sont celles du type $P(C_{l,c} = ... | A_{l_c} = ...)$. Celles-ci ne
peuvent pas être obtenues à partir de la base de données que nous avons
utilisées car il est nécessaire de conserver une trace de l'apparence. En
revanche, à partir du code fournit, il est possible d'apporter des modifications
permettant de calculer ces probabilités.
\\
Bien que les graphiques obtenus ne soient pas directement applicables aux bots,
ils présentent tout de même un intérêt.

\paragraph{Emplacement des portes secrètes}

\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{3d_sdoors_graph.png}}
  \caption{\label{fig:3d_sdoors_graph} Nombre de portes secrètes en fonction
    de la ligne et de la colonne}
\end{figure}

Ce graphique montre incontestablement que $P(C_{l,c} = PS)$ n'est pas indépendant
de $\{l,c\}$. Cette information encourage à approfondir les recherches
mentionnées ci-dessus, car il semble probable qu'il y ait des informations
utilisables si l'on suit la démarche indiquée au paragraphe précédent.
\\
De plus, bien que la probabilité semble être plus élevée suivant deux bandes
horizontales et faible aux alentours de la ligne 10, ce phénomène ne s'observe
pas par rapport aux colonnes. Les emplacements à l'intérieur de ces bandes ne
semblent pas équiprobables et la différence de probabilité y semble même assez
élevée. La probabilité de trouver une porte secrète dans les bords semble nulle.

\paragraph{Emplacement des couloirs secrets}

\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{3d_scorr_graph.png}}
  \caption{\label{fig:3d_scorr_graph} Nombre de couloirs secrets en fonction
    de la ligne et de la colonne}
\end{figure}

Ce graphique indique que les colonnes au bord de la cartes sont très peu
susceptibles de contenir des couloirs secrets tandis que la probabilité que les
lignes aux bord de la carte en contiennent n'est pas négligeable. On peut aussi
voir que les lignes centrales ont bien plus de chances de contenir un couloir
secret que celles du bord\footnote{Peut-être est-ce parce qu'il y a simplement
plus de couloirs au centre de la pièce que dans les bords, comme évoqué dans le
paragraphe {\em Événements indépendants}}.
\\
Ces observations encouragent aussi à approfondir les recherches générales sur
Nethack afin de pouvoir les utiliser pour améliorer des bots.

\subsection{Problème simplifié : sortie d'une salle}

Afin d'étudier le problème de la recherche des portes secrètes de façon plus
théorique, nous avons réduit le nombre de paramètres aléatoires et simplifié
volontairement la situation.
\\
Dans ce niveau particulier :
\begin{itemize}
\item Le personnage apparaît au milieu d'une salle de $10$ lignes par $10$
  colonnes.
\item La salle est entourée de murs et un seul de ceux-ci contient une porte
  secrète.
  \footnote{Il y a {\em exactement} une porte secrète}
\item Tous les emplacements ont la même probabilité de contenir la porte
  secrète.
  \footnote{Ce point a été vérifié par l'expérience en générant un grand nombre
    de parties et en observant la répartition des portes secrètes}
\item Effectuer une recherche dans une des cases adjacentes au mur contenant la
  porte secrète a une probabilité de révéler celle-ci de $\frac{1}{7}$.
\item Le personnage est placé aléatoirement dans la pièce.
\end{itemize}

Ces conditions sont assurées par l'utilisation d'un patch supplémentaire, venant
s'additionner à ceux mentionnés dans la partie {\em Analyses}.
\\
Voici un aperçu de l'apparence de la pièce, les carrés violets étant ceux où la
porte secrète peut se trouver.

\begin{center}
  \begin{tikzpicture}[scale=.5]
    % Drawing Walls part
    \foreach \x in {1,...,10}{
      \draw [fill=violet] (\x,  0) rectangle (\x + 1,  1);
      \draw [fill=violet] (\x, 11) rectangle (\x + 1, 12);
    }
    \foreach \y in {1,...,10}{
      \draw [fill=violet] ( 0, \y) rectangle ( 1, \y + 1);
      \draw [fill=violet] (11, \y) rectangle (12, \y + 1);
    }
    % Drawing internal grid
    \foreach \x in {1,...,10}{
      \foreach \y in {1,...,10}{
        \draw (\x,\y) rectangle (\x + 1,\y + 1);
      }
    }
  \end{tikzpicture}
\end{center}

Être certain d'avoir la meilleure stratégie étant trop complexe à nos yeux, nous
avons décider de chercher plutôt à définir une borne inférieure. Une fois
celle-ci obtenue, il est donc possible de la comparer aux résultats obtenus par
les bots. La différence entre ces deux résultats pourra être réduite de deux
façons :
\begin{itemize}
\item En augmentant la borne inférieure par des résultats théoriques.
\item En diminuant la borne supérieure par des modifications du bot.
\end{itemize}

\subsubsection{Approche théorique}

\paragraph{Dominer la pièce :}
Il est possible de fixer certaines cases où les recherches seront effectuées en
cherchant à minimiser ce nombre de cases, tout en ayant à portée tous les murs.
\footnote{Cette notion est comparable à la domination en théorie des graphes,
  les différences principales étant que l'on ne peut pas choisir n'importe quel
  sommet, certains sommets étant interdits et qu'il n'est pas nécessaire de
  dominer tous les sommets, mais uniquement les interdits.}
\\
En colorant en orange les cases où les recherches seront effectuées, et en
indiquant la portée des recherches par les carrés oranges transparents, le
résultat obtenu est le suivant :

\begin{center}
  \begin{tikzpicture}[scale=.5]
    % Drawing Walls part
    \foreach \x in {1,...,10}{
      \draw [fill=violet] (\x,  0) rectangle (\x + 1,  1);
      \draw [fill=violet] (\x, 11) rectangle (\x + 1, 12);
    }
    \foreach \y in {1,...,10}{
      \draw [fill=violet] ( 0, \y) rectangle ( 1, \y + 1);
      \draw [fill=violet] (11, \y) rectangle (12, \y + 1);
    }
    % Drawing internal grid
    \foreach \x in {1,...,10}{
      \foreach \y in {1,...,10}{
        \draw (\x,\y) rectangle (\x + 1,\y + 1);
      }
    }
    % Coloring squares and ranges of research
    \foreach \x in {1,4,7,10}{
      \draw [fill=orange] (\x,  1) rectangle (\x + 1,  2);
      \draw [fill=orange] (\x, 10) rectangle (\x + 1, 11);
      \draw [ultra thick, orange] (\x - 0.5, 0.5) rectangle (\x + 1.5,  2.5);
      \draw [ultra thick, orange] (\x - 0.5, 9.5) rectangle (\x + 1.5, 11.5);
    }
    \foreach \y in {1,4,7,10}{
      \draw [fill=orange] ( 1, \y) rectangle ( 2, \y + 1);
      \draw [fill=orange] (10, \y) rectangle (11, \y + 1);
      \draw [ultra thick, orange] (0.5, \y - 0.5) rectangle ( 2.5, \y + 1.5);
      \draw [ultra thick, orange] (9.5, \y - 0.5) rectangle (11.5, \y + 1.5);
    }
  \end{tikzpicture}
\end{center}
Il est assez évident qu'il est impossible de recouvrir chaque cases contenant
potentiellement une porte avec moins de carrés, car tous les coins\footnote{Ce
sont eux qui sont a portées du plus grand nombre de sommets à dominer.} sont
utilisés et aucune case n'est à portée de deux emplacements de recherches.

\paragraph{Évolution des probabilités :}
Si l'on ignore le coût des déplacements, prenant en compte uniquement les coûts
de recherche, le meilleur comportement semble être de commencer par chercher
dans les coins et d'utiliser ensuite les autres emplacements, ceci en
considérant qu'ils ont tous le même nombre de recherche au début. Il n'est en
revanche pas évident de déterminer si un coin sur lequel $n+1$ recherches ont
été effectuées a une chance plus élevée d'être à proximité d'une porte secrète
qu'un bord où $n$ recherches ont été effectuées.
\\
La probabilité initiale de découvrir une porte est égale à 
$\frac{1}{40} \times \frac{1}{7}$, la probabilité initiale de trouver une porte
secrète dans un coin est donc de : $4 \times \frac{1}{40} \times \frac{1}{7}$.
Lorsque des recherches sont effectuées, la partie représentant la probabilité de
trouver la porte secrète en sachant que l'on a cherché au bon endroit ne sera
pas modifiée ($\frac{1}{7}$). En revanche, la probabilité que la porte secrète
soit sur une case spécifique dépendra du nombre et de l'emplacement des
recherches déjà effectuées\footnote{Ce problème est semblable au fameux
problème de Mounty Hall, le point clé étant que l'on {\em sait} qu'il y a 
{\em exactement} une porte secrète parmi les 40 cases de murs}. Une intuition de
ce fait peut être donnée par l'exemple suivant : 10'000 recherches ont été
effectuées sur chacun des emplacements de recherches excepté sur celui se
situant en haut à gauche où aucune recherche n'a été effectuée, la probabilité
qu'une recherche sur cette case aboutissent est clairement de plus de 
$\frac{1}{10}$.
\\
Afin de présenter une preuve de cette différence de probabilité, nous allons
simplifier ce problème en considérant qu'il existe uniquement deux emplacements
où la porte secrète peut se trouver et que chaque recherche ne peut être à
portée que d'un seul d'entre eux.\\
On considère les notations suivantes :
\begin{itemize}
\item $Pos(P)$ est la position de la porte.
\item $T$ signifie que la porte a été trouvée.
\item $PT$ signifie que la porte n'a pas été trouvée.
\end{itemize}
Après une recherche en position $1$, on obtient l'arbre de probabilité suivant:

% Set the overall layout of the tree
\tikzstyle{level 1}=[level distance=3.5cm, sibling distance=3.5cm]
\tikzstyle{level 2}=[level distance=3.5cm, sibling distance=2cm]

% Define styles for bags and leafs
\tikzstyle{bag} = [text width=4em, text centered]
\tikzstyle{end} = [circle, minimum width=3pt,fill, inner sep=0pt]
\begin{center}
  \begin{tikzpicture}[grow=right, sloped]
    \node[bag] {Overall}
    child {
      node[bag] {Porte en $1$}        
      child {
        node[end] {}
        edge from parent
        node[above] {$T$}
        node[below]  {$\frac{1}{7}$}
      }
      child {
        node[end] {}
        edge from parent
        node[above] {$NT$}
        node[below]  {$\frac{6}{7}$}
      }
      edge from parent 
      node[above] {$Pos(P) = 1$}
      node[below]  {$\frac{1}{2}$}
    }
    child {
      node[bag] {Porte en $2$}
      child {
        node[end] {}
        edge from parent
        node[above] {$NT$}
        node[below]  {$1$}
      }
      edge from parent         
      node[above] {$Pos(P) = 2$}
      node[below]  {$\frac{1}{2}$}
    };
  \end{tikzpicture}
\end{center}

Si la première recherche a terminée sans que la porte n'ait été trouvée, les
nouvelles probabilités peuvent être aisément calculées :
\begin{itemize}
\item $P(Pos(P) = 1) = \frac{\frac{1}{2} \times \frac{6}{7}}
                            {\frac{1}{2} \times \frac{6}{7} +
                             \frac{1}{2}}
                     = \frac{6}{13}$
\item $P(Pos(P) = 2) = \frac{\frac{1}{2}}
                            {\frac{1}{2} \times \frac{6}{7} +
                             \frac{1}{2}}
                     = \frac{7}{13}$
\end{itemize}

\paragraph{Calcul de la probabilité :}
Nous avons déjà démontré que deux emplacements ne sont plus équiprobables si
plus de recherches ont été effectués sur l'un que sur l'autre. Il est aussi
évident que la méthode présentée ci-dessus sera très difficile à appliquer sur
un grand nombre de recherches. C'est pour cette raison que nous avons développé
une autre approche, permettant de calculer les probabilités de façon plus simple
et aussi beaucoup plus rapide pour un ordinateur.\\
À partir de l'arbre de probabilité présentés précédemment, il est facile de voir
que la probabilité qu'une recherche soit fructueuse dépend uniquement de la
probabilité qu'une porte cachée se situe à portée de l'endroit où est effectuée
la recherche.
\\
Afin de résoudre ce problème dans un cas plus général, nous définissons
certaines notations :
\begin{itemize}
\item $W$ est l'ensemble des emplacements de recherches.
  $W = \{W_0,W_1, ... , W_{|W| -1} \}$
\item $R(W_k)$ représente le nombre de recherche faîtes sur l'emplacement $W_k$.
\item $V(W_k)$ représente le nombre de voisins de l'emplacement $W_k$
  susceptibles de contenir une porte secrètes.
\item $P(W_k = V)$ représente la probabilité que la porte secrète soit voisine
  de l'emplacement $W_k$.
\item $p$ est la probabilité de trouver une porte sachant qu'un de ses voisins
  contient la porte secrète.\footnote{$\frac{1}{7}$ dans le cas étudié ici.}
\end{itemize}

En accord avec les règles de probabilités, on définit donc la probabilité
qu'une recherche aboutisse ainsi :
$$P(W_k = V) = \frac{\text{cas favorables}(W_k)}{\text{cas possibles}}$$
Ces deux éléments peuvent être définis ainsi :
\begin{itemize}
\item $\text{cas favorables}(W_k) = V(W_k) * (1-p)^{R(W_k)}$
\item $\text{cas possibles} = \sum\limits_{k=0}^{|W| - 1}{V(W_k) * (1-p)^{R(W_k)}}$
\end{itemize}

On aboutit donc à la formule suivante pour définir la probabilité que la porte
soit à portée de l'emplacement $W_k$:
$$ P(W_k = V) = \frac{V(W_k) *(1-p)^{R_k}}{\sum\limits_{k=0}^{|W| - 1}{V(W_k) * (1-p) ^{R_k}}}$$
Comme $\text{cas possibles}$ n'est pas fonction de $k$, il est possible de
comparer l'intérêt de différentes cases uniquement en comparant les valeurs de
$\text{cas favorables}(W_k)$.
\\
Dans notre situation:
\begin{itemize}
\item Pour les coins, $V(W_k) = 4$.
\item Pour les bords, $V(W_k) = 3$.
\end{itemize}
Soient $k_1$ et $k_2$ tels que:
\begin{itemize}
\item $W_{k_1}$ est un coin.
\item $W_{k_2}$ est un bord.
\item $R(W_{k_1}) - R(W_{k_2}) = i$ avec $(1-p)^i = \frac{3}{4}$ ce qui implique
  que $i = \frac{\log(\frac{3}{4})}{\log(1-p)}$.\footnote{$i = 1,866$ dans notre
    cas.}
\end{itemize}
On obtient
$$\begin{array}{l c l}
\text{cas favorables}(W_{k_1})
&= &V(W_{k_1}) * (1-p)^{R(W_{k_1})}\\
&= &4 * (1-p)^{R(W_{k_2}) + i}\\
&= &4 * (1-p)^{R(W_{k_2})} * (1-p)^i\\
&= &4 * (1-p)^{R(W_{k_2})} * \frac{3}{4}\\
&= &3 * (1-p)^{R(W_{k_2})}\\
&= &V(W_{k_2}) * (1-p)^{R(W_{k_2})}\\
&= &\text{cas favorables}(W_{k_2})
\end{array}$$
Une implication importante de ce résultat est que pour un nombre de recherches
$n$, l'idéal sera que chaque coin ait eu $i$ recherches de plus que chaque bord.
De plus, la valeur de ce $i$ dépendra uniquement de $p$.

\paragraph{Minoration du nombre moyen de recherches :}
Si l'on désire minimiser le nombre moyen de recherches\footnote{Sans prendre du
  tout en compte le nombre de déplacements nécessaires}, il faut toujours
rechercher à l'emplacement ayant la plus haute probabilité d'être proche d'une
porte secrète. En effet, les chances que la porte soit trouvée sont maximales
pour un nombre de recherches $k$ si l'on se trouve dans un cas où les différents
emplacements de recherches ont des probabilités aussi proches que possibles.
\\
Nous noterons :
\begin{itemize}
\item $P_k$ : La probabilité de trouver la porte secrète en $k$ recherches au
  maximum.
\item $R_k$ : La probabilité de trouver la porte secrète en exactement $k$
  recherches.
\item $P(door)$ : La probabilité que la porte soit à l'emplacement de la
  recherche, cet emplacement est choisi comme étant le plus probable au moment
  de la recherche. Cette probabilité est calculée à l'aide de la formule trouvée
  précédemment.
\item $p$ : La probabilité de trouver la porte sachant qu'elle est voisine de la
  case où la recherche a été effectuée.
\end{itemize}
On obtient donc :
$$P_{k+1} = P_k + (1 - P_k) * P(door) * p$$
$$R_{k+1} = P_{k+1} - P_{k}$$
Quelque soit la stratégie choisie, il est donc évident que le nombre moyen de
recherches sera supérieur ou égal à $\sum\limits_{k=0}^{\infty} k * R_k$.
\\
Nous avons minoré cette valeur à l'aide d'un programme faisant l'addition de ces
termes tant que $R_k > 10^{-10}$ et nous avons obtenu environ $77,75$.

\subsubsection{Comparaison des résultats expérimentaux avec les valeurs
  théoriques}
La moyenne du nombre d'actions nécessaire au bot diffusion pour ouvrir la porte
sur 100 parties était de $158$, ce résultat est relativement proche de la borne
inférieure ($77,75$) si l'on prend en compte que la borne inférieure a été
calculée en ignorant totalement le coût des mouvements. En effet, afin
d'optimiser le nombre d'action moyen, le bot est obligé d'effectuer plusieurs
recherches sur un emplacement tandis que la stratégie utilisée pour calculer la
borne inférieure coûterait un nombre d'action très élevé en raison du nombre de
déplacements élevés qu'elle utilise.
\begin{figure}[H]
  \center{\includegraphics[width=\textwidth]{../images/compare.png}}
	\caption{\label{fig:compare} Graphique comparant les valeurs expérimentales du
  bot diffusion aux valeurs obtenues.}
\end{figure}

Une possibilité d'augmenter la borne inférieure pourrait être de minorer le
nombre de mouvement moyen. En effet, si l'on ignore totalement le coût des
recherches, il reste tout de même un nombre de mouvement non négligeable à
effectuer afin d'arriver à portée de la porte secrète (dont on ignore la
position).

\section{Documentation}
TODO: Utilisation de Doxygen, manuel d'utilisation, nombreux README, commentaires de
code (hors Doxygen), etc.

\section{Tests}
Bien que nous n'ayons pas développés à proprement parler de tests unitaires au
cours de notre projet, nous n'avons pas négligé le fait de tester notre code. Au
fur et à mesure que notre projet avançait, les possibilités de tester
automatiquement le code et de le tester de manière fiable se sont améliorées.
Commençant par jouer des parties à la main pour vérifier l'absence d'erreur,
nous avons terminé par pouvoir comparer les distributions obtenues pour certains
bots avec les distributions attendues. Nous avons aussi pu collecter les graines
des parties qui posaient certains problèmes et les réutiliser pour vérifier que
nos interventions résolvaient effectivement les problèmes et que nos
modifications n'en faisaient pas réapparaître d'autres.
\paragraph{}
Afin de diagnostiquer les erreurs, nous avons entre autre pu nous servir du
{\em dummy client}, le principal défaut de tous ces tests étant qu'ils restent
des tests experts et ne peuvent donc pas être lancés par n'importe qui, validant
simplement les modifications.
\paragraph{}
Le {\em viewer} et les fichiers de logs nous ont aussi permis d'analyser des
dysfonctionnements qui provenaient des bots afin de les corriger. Le module de
visualisation de l'exploration {\em toTikz} permet aussi de mieux comprendre les
problèmes du bot.

\subsection*{Repérage des problèmes}
Utilisation du viewer pour comprendre ce qui ne va pas, utilisation de gdb,
quelques tentatives infructueuses de test de couverture (gcov), de profilage
(gprof) et mémoire (valgrind).

\section{Travail en équipe, organisation}

Bien que la conception du programme se soit effectuée au sein d'un groupe
de sept personnes, une séparation a eu lieu à mi-parcours, et c'est à trois que
s'est déroulée la phase de développement. Sans s'attarder sur les raisons de
cette séparation, il est nécessaire de l'évoquer afin de comprendre les
comparaisons qui seront faîtes.
\subsection{Utilisation de git :}
Lors de la première partie du projet, nous avions trois profils différents par
rapport à git :
\begin{itemize}
\item Ceux qui ne connaissait pas git et qui n'ont pas réussi à apprendre à s'en
  servir.
\item Ceux qui ne connaissait pas ou peu git et qui ont appréhendé réellement
  cet outil pendant cette phase.
\item Ceux qui connaissaient déjà git.
\end{itemize}
Au cours de la seconde partie en revanche, chacun de nous a pu apprendre à mieux
se servir de cet outil, se familiarisant plus avec la notion de branches et nous
avons réussi à comprendre de mieux en mieux les commits des autres, en essayant
de privilégier autant que possible des commits légers.
\\
L'utilisation des branches et des diff de git nous ont permis de créer les
patchs facilement sans interférer sur d'autres travaux. Nous avons pu réduire
rapidement le nombre de branche et travailler plus facilement les uns avec les
autres\footnote{Ceci étant peut-être dû à la taille de l'équipe.}. Cette façon
de travailler nous a permis de garder en permanence une branche fonctionnelle
tout en réglant certains problèmes en plusieurs commits.
\\
Lorsque nous modifions des détails dans le protocole, en ouvrant une autre
branche, chacun pouvait apporter les modifications nécessaires pour que tous les
bots acceptent ce changement.
\\
Nous avons aussi utilisé les {\em issues} github pour noter les problèmes qui
apparaissaient, entre autre afin de ne pas oublier qu'ils n'étaient pas traités.

\subsection{Différences d'organisation :}
Le fait que l'équipe ait été séparée en deux a modifié la nature du projet et
des difficultés auxquels nous avons du faire face. Il est en effet évident que
les problématiques de gestion de groupe qui se posent lors du développement à
sept personnes ne sont pas les mêmes qu'à trois.
\\
Durant la première partie du développement, bien que les tâches aient été
attribuées, l'équipe n'a pas fonctionné comme elle l'aurait dû. Nous avons
néanmoins pu planifier l'organisation. Les raisons de l'échec organisationnel de
cette première partie ne peuvent pas être définies aisément, mais il est
évident que notre groupe a pu beaucoup mieux fonctionner au cours de cette
seconde partie.
\\
Nous éprouvons tous une certaine frustration quand au fait que cette séparation
ait été nécessaire. En effet, malgré nos efforts, nous n'avons pas réussi à
faire fonctionner cette équipe et nous n'avons donc pas pu nous frotter
réellement aux difficultés qui apparaissent lors du travail dans des équipes
plus grandes. En revanche, pendant la seconde phase, nous avons bien réussi à
collaborer et à apprendre les uns des autres.

\subsection{Conventions}
Comme une partie de notre projet consiste à créer des patchs et à s'insérer dans
du code existant, il nous semblait naturel de chercher à adopter les conventions
utilisées par Nethack afin d'obtenir une certaine homogéneité dans celui-ci.
Les standards de codage variant à l'intérieur du projet et étant assez loin de
ceux auxquels nous sommes habitués, nous avons donc décidé trouver un juste
milieu en s'axant sur certains critères.
\begin{itemize}
\item {\em La langue :}\\
  Bien que le manuel et le rapport soient écrit en français,
  nous avons décidé de conserver l'anglais aussi bien pour le code et ses
  commentaires que pour les readme. Ce choix permet d'éviter de trop mélanger
  les appellations.
\item {\em L'utilisation des tabulations et des espaces :}\\
  Nethack mêlant les tabulations et les espaces, nous avons décidé de vérifier
  que quelque soit la taille d'affichage de la tabulation, nos patchs modifient
  le code de façon cohérente avec le code environnant. Pour le code extérieur à
  Nethack, nous avons choisi d'utiliser des tabulations pour marquer
  l'indentation et des espaces pour l'alignement, permettant ainsi aux
  utilisateurs de visualiser le code avec l'indentation qu'ils préfèrent, sans
  pour autant gâcher les alignements.
\item {\em La largeur de ligne maximale :}\\
  Dans la plupart de nos fichiers textes\footnote{Fichiers sources, README,
    fichiers tex, etc...} nous avons cherché à éviter que les lignes dépassent
  80 caractères, non seulement pour faciliter la lecture quelque soit l'outil
  utilisé, mais aussi pour permettre de visualiser plus facilement les
  différences apportées par des commits.
\item {\em Le nommage des variables et des fonctions :}\\
  Mis à part pour le code des bots en java qui suit un nommage CamelCase,
  nous avons décidé d'adopté un nommage à base d'underscore, comme utilisé dans
  nethack.
\item {\em Les accolades}\\
  Nous avons uniformisés le positionnement des accolades afin de faciliter la
  lecture du code.
\end{itemize}

Toutes les règles présentées ci-dessus sont celles que nous avons essayé de
respecter, néanmoins, nous avons plus considérés ces règles comme des sortes de
guides que comme une procédure stricte, il existe donc certainement des
exceptions à celles-ci dans le projet.

\section{Améliorations possibles}
Ce projet peut servir de base pour essayer différents bots d'exploration,
et pour valider leur efficacité par des expériences pratiques. Il peut aussi
être enrichi afin de présenter plus de fonctionnalités, de modes, de bots ou
encore d'étude théorique. Plusieurs de ces perspectives de continuation seront
décrites ici afin de donner des pistes à quiconque souhaiterait enrichir ce
projet.

\subsection{Fonctionnement de Nethack}
\subsubsection{Désactiver les niveaux spéciaux}
Aucun des patchs que nous avons créé ne modifie la génération des niveaux
original. Si ce fait ne nous a pas posé de problèmes lorsque les bots se
limitaient à l'exploration du premier niveau, cela s'est révélé être un problème
lorsque le but donné aux bots était de descendre dans le niveau le plus bas
possible. En effet, il se retrouvait toujours arrêté par des niveaux prédéfinis
qui présentait une spécificité\footnote{Pour certains niveaux, il était
nécessaire d'accomplir une quête pour pouvoir déverrouiller des portes, ces
interactions n'étant pas spécifiées par notre protocole, il était impossible que
le bot atteigne le niveau suivant.}.
\\
Si l'on souhaite atteindre le niveau le plus profond sans demander aux bots de
faire ces interactions, il peut être nécessaire de désactiver dans le noyau de
Nethack le risque que des niveaux spécifiques soient utilisés, s'assurant ainsi
que tous les niveaux sont générés aléatoirement.

\subsubsection{Désactiver les portes piégées}
Bien que nous ayons pu vérifier par l'expérience que les bots ne rencontraient
plus de pièges dans le premier niveau une fois le patch {\verb|disable-traps|}
appliqué, nous avons encore rencontré des portes piégées dans les niveaux
inférieurs\footnote{Ceci est probablement dû au fait que les pièges au sol ne
sont pas traités de la même façon que les pièges placés sur les portes.}. Afin
d'éviter ces événements qui ne respectent pas la présentation du mode, il serait
nécessaire de faire un patch de plus, assurant que ce type particulier de pièges
disparaisse.

\subsubsection{Stocker la cause de la fin de la partie}
Bien que la plupart des parties se terminent car le nombre de tours autorisés
est épuisé, il est possible que certains événements \footnote{Par exemple la
  mort du personnage, ou la détection d'un trop grand nombre d'ordres
  invalides.} entraînent une fin précoce. Dans ces cas, il serait intéressant
de pouvoir enregistrer la raison de cette fin dans la base de donnée, en vue de
produire des statistiques où simplement pour rejouer ces parties afin de
chercher à résoudre des failles éventuelles.

\subsubsection{Ajouter des causes de fin de partie}
Actuellement, il existe uniquement 3 causes possibles pour qu'une partie se
termine :
\begin{itemize}
\item Utilisation de l'intégralité des mouvements disponibles.
\item Mort du personnage.\footnote{Ceci n'est pas un événement habituel étant
  donné que nous souhaitions retirer toutes les causes potentielles de morts du
  personnage.}
\item Détection d'une boucle infinie.\footnote{Ceci est simplement fait dans le
  cas où un bot envoie trop d'ordre invalides à la suite}
\end{itemize}

Cependant, suivant le mode utilisé, certains événements pourraient déclencher
une fin anticipée afin d'épargner du temps de calcul utilisé inutilement. La
contrainte de ces détections étant de ne pas risquer de modifier les
performances du bot.
\\
Dans le mode qui consiste à rechercher les portes secrètes et les couloirs
secrets d'un niveau, les parties pourraient être arrêté dès que toutes les
portes et les couloirs secrets ont été trouvés. On peut aussi imaginer que
l'ordre de descendre les escaliers entraîne une fin prématurée pour cause
d'action interdite.
\\
Dans le mode où le bot doit chercher la seule porte cachée, il est aussi
possible d'arrêter le jeu dès que celle-ci a été trouvée, réduisant ainsi de
manière significative la durée moyenne des parties.

\subsubsection{Ajouter de modes différents}
Tous les modes présents actuellement se ressemble beaucoup, puisqu'ils
concernent tous l'exploration et ne diffèrent que par leurs objectifs ou par le
contenu des niveaux. Ajouter des modes où le personnage devrait par exemple
combattre ou encore ramasser le plus d'or possible permettrait une plus grande
diversité et peut-être qu'en combinant les différents bots ensemble, il serait
possible d'obtenir un bot capable d'explorer une version non-modifiée de
Nethack.

\subsubsection{Résoudre le problème du sémaphore}
Dans la version actuelle du projet, lorsqu'un utilisateur tue un processus de
Nethack alors que celui-ci était en train d'écrire dans la base de donnée, il se
termine immédiatement, sans même prendre le temps de libérer le sémaphore qu'il
a bloqué en entrant dans la section critique qu'est l'ajout d'une entrée à la
base de données. À l'aide d'un gestionnaire de signaux, il est peut-être
possible d'assurer le fait que le sémaphore soit tout de même libéré avant
l'extinction de Nethack. Comme cette zone critique contient des appels à des
fonctions appartenant à la bibliothèque {\verb|sqlite3|}, il est envisageable
que la gestion des signaux de celle-ci interfère avec celle définie pour régler
le problème du sémaphore.

\subsubsection{Conserver plus d'historiques}
Lorsqu'une série de partie intensive est lancée à partir d'un script, les
historiques permettant de rejouer une partie ne peuvent pas être conservés.
Fournir aux utilisateurs une fonctionnalité leur permettant de pouvoir revoir la
partie sans avoir à la rejouer peut se révéler utile, pour cela, il est possible
soit d'utiliser une variable d'environnement pour transmettre à Nethack le
chemin désiré pour ce fichier. Soit de déplacer ce fichier après chaque
exécution de Nethack afin de le conserver.
%TODO est-ce envisageable avec la taille du fichier?

\subsection{Bots}
\subsubsection{Diminuer le temps de calcul du bot diffusion}
\subsubsection{Développer d'autres starter packages}
\subsubsection{Complexifier le problème}
\subsection{Analyse}
\subsubsection{Approfondir l'étude de la pièce spécifique}
\subsubsection{Générer des données utililisables par les bots}


\section{Conclusion}
TODO

\end{document}
